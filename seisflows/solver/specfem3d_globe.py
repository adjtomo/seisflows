#!/usr/bin/env python3
"""
This class provides utilities for the Seisflows solver interactions with
Specfem3D Globe. It is built on top of the Specfem base class.

Some key differences between 3D and 3D_GLOBE implementations:

    1) SPECFEM3D_GLOBE does not require 'xgenerate_databases' which is
        required for Cartesian.
    2) Related to (1), we do NOT want to re-run the mesher, event at
        the very beginning. The Solver will simply re-load GLL model
        when run with a valid GLL model
    3) 3DGLOBE cannot toggle attenuation on/off. If it was on to create
        the model, it MUST be on for the solver (otherwise throws
        a weird 'recompile solver' error)
    4) Does not allow SU seismogram outputs, only ASCII, SAC, ASDF, 3D_Array
    5) SPECFEM3D_GLOBE ASCII synthetics have extension '.ascii', but
        the adjoint sources are NOT supposed to have this, i.e., they
        should have extension '.adj'
    6) 3DGLOBE breaks its files into 3 regions (reg1: mantle, reg2: outer core,
        reg3: inner core) which affects file bookkeeping
"""
import os
from glob import glob
from seisflows import logger
from seisflows.tools import unix
from seisflows.tools.specfem import setpar, getpar
from seisflows.solver.specfem import Specfem


class Specfem3DGlobe(Specfem):
    """
    Solver SPECFEM3D_GLOBE
    ----------------------
    SPECFEM3D_Globe-specific alterations to the base SPECFEM module

    Parameters
    ----------
    :type source_prefix: str
    :param source_prefix: Prefix of source files in path SPECFEM_DATA. Must be
        in ['CMTSOLUTION', 'FORCESOLUTION']. Defaults to 'CMTSOLUTION'
    :type export_vtk: bool
    :param export_vtk: at the finalization step of each iteration, convert
        all eligible model and gradient directories in the `path_output`
        to .vtk files for visualization using ParaView (or similar programs). 
        Files are exported to `path_output`/VTK
    :type prune_scratch: bool
    :param prune_scratch: prune/remove database files as soon as they are used,
        to keep overall filesystem burden down
        - removes *.vt? files after they're generated by a forward simulation
        - removes proc*_absorb_field.bin and proc*_save_forward_array.bin
            files after adjoint simulations
    :type regions: str
    :param regions: which regions of the chunk  to consider in your 'model'. 
        Valid regions are 1, 2 and 3. If you want all regions, set as '123'. 
        If you only want region 1, set as  '1', etc. Order insensitive. 
    :type smooth_type: str
    :param smooth_type: choose how smoothing is performed for gradients.
        these are tied to the internal smoothing functions available.
        - 'gaussian': convolve with a 3D gaussian, slow and computationally
            intensive, but default and matches 2D and 3D_Cartesian smoothing
        - 'laplacian' (default): average points around vertex to smooth. 
            faster and preferred method for GLOBE code
    :type mask_source: bool
    :param mask_source: mask the source region of the gradient to avoid high
        amplitude updates around source region. If True, uses the SPECFEM 
        parameter 'SAVE_SOURCE_MASK' to output source mask files and applies
        source mask to event kernel during gradient calculation.
    :type scale_mask_source: float
    :param scale_mask_region: only used if `mask_source` == True. the output
        source mask from SPECFEM3D_GLOBE is an array of ones (1) with a 3D 
        gaussian ceneterd on the source region which approaches 0 at the 
        hypocenter. However, for kernels that have very small amplitudes (<1E-5)
        the amplitudes of the mask may not be sufficient to suppress the high
        amplitude source region kernel. This fudge factor allows the User to
        scale the source mask to better suppress the source region. ONLY the
        source mask region will be multiplied by this value. Defaults to False 
        (no modification), if set to 0, entire source mask region will act as
        a cutout. Trial and error will be required to determine a useful value
        that is not 0 or 1. Note that this parameter is not actually used by
        the solver, it is used by the Migration workflow, but it is kept here
        for consistency.


    Paths
    -----
    ***
    """
    __doc__ = Specfem.__doc__ + __doc__

    def __init__(self, source_prefix="CMTSOLUTION", export_vtk=True,
                 prune_scratch=True,  regions="123", smooth_type="laplacian", 
                 mask_source=False, scale_mask_region=False, **kwargs):
        """
        Instantiate a Specfem3D_Globe solver interface
        
        .. note:: Repeated variables

            For variables that are expressed as both public and private (one
            leading underscore), we have a public version so that the parameter
            will show up in the parameter file, and a private one so that the 
            other SPECFEM versions can use it for boolean logic without
            necessarily needing to include it in their parameter file since it
            is not accessed and therefore not necessary.
        """
        super().__init__(source_prefix=source_prefix, **kwargs)

        self.smooth_type = smooth_type
        self.prune_scratch = prune_scratch
        self.mask_source = mask_source
        self.scale_mask_region = scale_mask_region

        # See note about repeated variables above
        self.export_vtk = export_vtk
        self._export_vtk = export_vtk

        # See note about repeated variables above
        self.regions = str(regions)
        self._regions = sorted(self.regions) 

        # Define parameters based on material type
        if self.materials.upper() == "ACOUSTIC":
            self._parameters += ["vp"]
        elif self.materials.upper() in ["ELASTIC", "ISOTROPIC"]:
            self._parameters += ["vp", "vs"]
        elif self.materials.upper() == "ANISOTROPIC":
            self._parameters += ["vpv", "vph", "vsv", "vsh", "eta"]

        # Append regions to to the parameters, e.g., 'reg1_vpv'
        overwrite_parameters = []
        for reg in self._regions:
            overwrite_parameters.extend([f"reg{reg}_{_}" for _ in 
                                        self._parameters])
        self._parameters = sorted(overwrite_parameters)

        # Overwriting the base class parameters
        self._syn_available_data_formats = ["ASCII"]
        self._acceptable_source_prefixes = ["CMTSOLUTION", "FORCESOLUTION"]
        self._acceptable_smooth_types = ["laplacian", "gaussian"]
        self._required_binaries = ["xspecfem3D", "xmeshfem3D", "xcombine_sem"]
        if smooth_type == "laplacian":
            self._required_binaries.append("xsmooth_laplacian_sem")
        else:
            self._required_binaries.append("xsmooth_sem")

        # Overwriting constants that will be referenced during simulations 
        self._fwd_simulation_executables = ["bin/xmeshfem3D", "bin/xspecfem3D"]
        self._adj_simulation_executables = ["bin/xspecfem3D"]
        self._absorb_wildcard = "proc??????_reg?_absorb_buffer*"
        self._forward_array_wildcard = "proc??????_save_forward_arrays*"

        # Internally used parameters set by functions within class
        self._model_databases = None
        self._kernel_databases = None
        self.path._vtk_files = os.path.join(self.path.scratch, "vtk_files")

    def check(self):
        """
        Checks parameter validity for SPECFEM3D_GLOBE parameters
        """
        super().check()
        
        assert(self.smooth_type in self._acceptable_smooth_types), \
            f"`smooth_type` must be in {self._acceptable_smooth_types}" 

        # Check that regions are some combination of 1, 2 and/or 3
        for r in self._regions:
            assert(int(r) in [1, 2, 3]), (
                f"`regions` must be some integer combination 1, 2 and/or 3"
                )

        # Check that the DATA/ sub-directory crust2.0 is available.
        # SPECFEM3D_GLOBE quirk requires this as a base model for GLL updates
        for fid in ["s362ani", "crust2.0", "topo_bathy"]:  # !!! CHECK THIS
            if not os.path.exists(os.path.join(self.path.specfem_data, fid)):
                logger.warning(f"`path_specfem_data`/{fid} is required for "
                               f"SPECFEM3D_GLOBE to use GLL models"
                               )
                
        # Set SPECFEM parameter 'SAVE_SOURCE_MASK' if requested by User
        if self.mask_source:
            source_mask = getpar(key="SAVE_SOURCE_MASK", 
                                 file=os.path.join(self.path.specfem_data,
                                                   "Par_file"))[1]
            if source_mask != ".true.":
                logger.info("updating SPECFEM parameter "
                            "`SAVE_SOURCE_MASK` = .true.")
                setpar(key="SAVE_SOURCE_MASK", val=".true.", 
                       file=os.path.join(self.path.specfem_data, "Par_file"))

    def data_wildcard(self, comp="?"):
        """
        Returns a wildcard identifier for synthetic data
        Currently only support for ASCII seismograms

        :rtype: str
        :return: wildcard identifier for channels
        """
        if self.syn_data_format.upper() == "ASCII":
            return f"*.?X{comp}.sem.ascii"
    
    @property
    def kernel_databases(self):
        """
        The location of kernel output files, for 3DGLOBE usually DATABASES_MPI. 
        This can be determined by 'LOCAL_PATH' in the Par_file. Points to
        `model_databases` as it is assumed they are the same path
        """
        if self._kernel_databases is None:
            self._kernel_databases = self.model_databases

        return self._kernel_databases

    @property
    def model_databases(self):
        """
        The location of model output files, for 3DGLOBE usually DATABASES_MPI. 
        This can be determined by 'LOCAL_PATH' in the Par_file and must be 
        defined relative to the main directory
        """
        if self._model_databases is None:
            self._model_databases = getpar(
                key="LOCAL_PATH", file=os.path.join(self.path.specfem_data,
                                                    "Par_file"))[1]
        return os.path.basename(self._model_databases)

    def adjoint_simulation(self, **kwargs):
        """
        Supers SPECFEM for adjoint solver and removes GLOBE-specific fwd files
        Also deals with anisotropic kernels (or lack thereof)
        """
        # Make sure we have a STATIONS_ADJOINT file. Simply copy STATIONS file
        dst = os.path.join(self.cwd, "DATA", "STATIONS_ADJOINT")
        if not os.path.exists(dst):
            src = os.path.join(self.cwd, "DATA", "STATIONS")
            unix.cp(src, dst)

        # Control the kernel quantities generated by SPECFEM
        if self.materials.upper() in ["ACOUSTIC", "ELASTIC", "ISOTROPIC"]:
            anisotropic_kl = ".false."
            save_transverse_kl_only = ".false."
        elif self.materials.upper() == "ANISOTROPIC":
            anisotropic_kl = ".true."
            save_transverse_kl_only = ".true."
        else:
            raise NotImplementedError("unexpected value for `solver.materials`")

        unix.cd(self.cwd)
        setpar(key="ANISOTROPIC_KL", val=anisotropic_kl, file="DATA/Par_file")
        setpar(key="SAVE_TRANSVERSE_KL_ONLY", val=save_transverse_kl_only, 
               file="DATA/Par_file")
        
        # SPECFEM3D class takes care of attenuation and STATIONS_ADJOINT file
        super().adjoint_simulation(**kwargs)
        
        # Export the source mask files so that Workflow can find them later.
        if self.mask_source:
            dst = os.path.join(self.path.eval_grad, "mask_source", 
                               self.source_name)
            unix.mkdir(dst)
            # Don't overwrite existing files because they will be the same
            if glob(os.path.join(dst, "*")):
                logger.debug("source mask files already exist in directory, "
                             "will not transfer new files")
                return
            # Check that the adjoint simulation actually created requisite files
            mask_files = glob(
                os.path.join(self.cwd, self.model_databases, 
                             self.model_wildcard(par="reg?_mask_source"))
                             )
            if not mask_files:
                logger.warning("no source mask files found despite parameter "
                               "`mask_source`=True")
                return

            logger.debug(f"moving source mask files to {dst}")
            unix.mv(src=mask_files, dst=dst)


    def combine(self, input_paths, output_path, parameters=None):                 
        """
        Overwrite of xcombine_sem with an additional file check as 
        SPECFEM3D_GLOBE requires file 'mesh_parameters.bin'
                                                                                 
        :type input_paths: str                                                    
        :param input_paths: list of paths to directories containing binary
            files to be combined
        :type output_path: str
        :param output_path: path to export the outputs of xcombine_sem           
        :type parameters: list                                                   
        :param parameters: optional list of parameters,                          
            defaults to `self._parameters`                                       
        """
        if parameters is None:
            parameters = self._parameters

        # Switch to relative pathing
        unix.cd(self.cwd)

        # Copy the 'mesh_parameters.bin' from LOCAL_PATH. Assumed to be the 
        # same for all tasks
        src = os.path.join(self.model_databases, "mesh_parameters.bin")
        for input_path in input_paths:
            dst = os.path.join(input_path, "mesh_parameters.bin")
            unix.cp(src, dst)
        
        # 3DGLOBE 'xcombine_sem' does not expect `reg?_` prefix, strip off
        stripped_parameters = list(set([_[5:] for _ in parameters]))

        super().combine(input_paths=input_paths, output_path=output_path,
                        parameters=stripped_parameters)

    def smooth(self, input_path, output_path, parameters=None, span_h=None,      
               span_v=None, use_gpu=False):                                      
        """
        Logic function to choose between available smoothing types for GLOBE
                                                                                 
        :type input_path: str                                                    
        :param input_path: path to data                                          
        :type output_path: str                                                   
        :param output_path: path to export the outputs of xcombine_sem           
        :type parameters: list                                                   
        :param parameters: optional list of parameters,                          
            defaults to `self._parameters`                                       
        :type span_h: float                                                      
        :param span_h: horizontal smoothing length in meters                     
        :type span_v: float                                                      
        :param span_v: vertical smoothing length in meters                       
        :type use_gpu: bool                                                      
        :param use_gpu: whether to use GPU acceleration for smoothing. Requires  
            GPU compiled binaries and GPU compute node.                          
        """
        if parameters is None:
            parameters = self._parameters

        # 3DGLOBE 'xsmooth_*sem' does not expect `reg?_` prefix, strip off
        stripped_parameters = list(set([_[5:] for _ in parameters]))

        if self.smooth_type == "gaussian":
            super().smooth(input_path=input_path, output_path=output_path, 
                           parameters=stripped_parameters, span_h=span_h, 
                           span_v=span_v, use_gpu=use_gpu)
        elif self.smooth_type == "laplacian":
            self.smooth_laplacian(
                    input_path=input_path, output_path=output_path, 
                    parameters=stripped_parameters, span_h=span_h, span_v=span_v
                    )

    def smooth_laplacian(self, input_path, output_path, parameters=None, 
                         span_h=None, span_v=None):
        """                                                                      
        Wrapper for SPECFEM binary: xsmooth_laplacian_sem

        Smooths kernels by with Laplacian smoothing which takes averages of a
        mesh corner with all it's surrounding points.

        .. note::
            Externally this smooth function behaves almost identically to
            the normal gaussian smoothing function
                                                                                 
        .. note::                                                                
            It is ASSUMED that this function is being called by                  
            system.run(single=True) so that we can use the main solver           
            directory to perform the kernel smooth task                          
                                                                                 
        :type input_path: str                                                    
        :param input_path: path to data                                          
        :type output_path: str                                                   
        :param output_path: path to export the outputs of xcombine_sem           
        :type parameters: list                                                   
        :param parameters: optional list of parameters,                          
            defaults to `self._parameters`                                       
        :type span_h: float                                                      
        :param span_h: horizontal smoothing length in km
        :type span_v: float                                                      
        :param span_v: vertical smoothing length in km
        """                                                                      
        unix.cd(self.cwd)                                                        
                                                                                 
        # Assign some default parameters from class attributes if not given      
        if parameters is None:                                                   
            parameters = self._parameters                                        
        if span_h is None:                                                       
            span_h = self.smooth_h 
        if span_v is None:                                                       
            span_v = self.smooth_v
                                                                                 
        logger.debug(f"smoothing {parameters} with laplacian, horizontal span "
                     f"{span_h}m and vertical span {span_v}m")               

        # NOTE: Converting smoothing lengths 'm' -> 'km' as laplacian smoothing
        #   function is expecting things in 'km' while SeisFlows expects things
        #   in 'm'
        span_h *= 1E-3
        span_v *= 1E-3

        if not os.path.exists(output_path):                                      
            unix.mkdir(output_path)                                              
                                                                                 
        # Ensure trailing '/' character, required by xsmooth_sem                 
        input_path = os.path.join(input_path, "")                                
        output_path = os.path.join(output_path, "")                              

        # mpiexec ./bin/xsmooth_laplacian_sem SIGMA_H SIGMA_V name input output
        for name in parameters:                                                  
            exc = (f"bin/xsmooth_laplacian_sem {str(span_h)} {str(span_v)} "
                   f"{name}_kernel {input_path} {output_path}")
            # e.g., combine_vs.log                                               
            stdout = f"{self._exc2log(exc)}_{name}.log"                          
            self._run_binary(executable=exc, stdout=stdout)                      
                                                                                 
        # Rename output files to remove the '_smooth' suffix which SeisFlows     
        # will not recognize                                                     
        files = glob(os.path.join(output_path, "*"))                             
        unix.rename(old="_smooth", new="", names=files)
        
    def combine_vol_data_vtk(self, input_path, output_path, hi_res=False,
                             parameters=None):
        """
        Wrapper for 'xcombine_vol_data_vtk'. Combines binary files together
        to generate a single .VTK file that can be visualized by external
        software like ParaView. Different call structure from Cartesian version.

        .. rubric::

            xcombine_vol_data_vtk slice list filename \
                input_topo_dir input_file_dir output_dir resolution region (opt)

        .. note::

            It is ASSUMED that this function is being called by
            system.run(single=True) so that we can use the main solver
            directory to perform the kernel summation task

        :type input_path: str
        :param input_path: path to files that are to be summed, can be different
            from the database files of the solver (e.g., if kernel files have
            been moved to another destination)
        :type output_path: strs
        :param output_path: path to export the outputs of xcombine_sem
        :type hi_res: bool
        :param hi_res: Set the high resolution flag to 1 or True, which will
            generate .vtk files with data at EACH GLL point, rather than at each
            nodal vertex. These files are LARGE, and we discourage using
            `hi_res`==True unless you know you want these files.
        :type parameters: list
        :param parameters: list of parameter names that should be combined to
            get individual VTK files. Parameter names do NOT require the 'reg'
            prefix, e.g., submit 'vsh_kernel', not 'reg1_vsh_kernel'
        """
        # Expand paths incase they are relative paths
        input_path = os.path.abspath(input_path)
        output_path = os.path.abspath(output_path)

        # Change to the MAINSOLVER directory so we can use its machinery for 
        # VTK combinations
        unix.cd(self.cwd)

        if parameters is None:
            parameters = self._parameters

        if not os.path.exists(output_path):
            unix.mkdir(output_path)

        # Call on xcombine_sem to combine kernels into a single file
        for name in list(parameters):
            exc = f"bin/xcombine_vol_data_vtk all {name} " \
                  f"DATABASES_MPI/ {input_path} {output_path} {int(hi_res)}"
            stdout = f"{self._exc2log(exc)}_{name}.log"
            self._run_binary(executable=exc, stdout=stdout, with_mpi=False)

    def import_model(self, path_model):
        """
        SPECFEM3D_GLOBE acts differently than the Cartesian version when
        running GLL models. The User must put the GLL model files in
        directory DATA/GLL (default, manually set PATHNAME_GLL_modeldir in
        constants.h), and run the mesher to incorporate any model updates.

        The updated GLL model files for iterative inversions need to be stored
        in a specific directory. Here it is hardcoded to the default value for
        SPECFEM3D_GLOBE constant `PATHNAME_GLL_modeldir`, which is specified in
        `src/constants.h` as "DATA/GLL"

        :type path_model: str
        :param path_model: path to an existing starting model
        """
        assert(os.path.exists(path_model)), f"model {path_model} does not exist"
        unix.cd(self.cwd)

        # Copy the model files (ex: proc000023_vp.bin ...) into database dir
        src = glob(os.path.join(path_model, f"*{self._ext}"))
        dst = os.path.join(self.cwd, "DATA", "GLL", "")
        if not os.path.exists(dst):
            unix.mkdir(dst)

        unix.cp(src, dst)

