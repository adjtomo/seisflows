#!/usr/bin/env python3
"""
This class provides utilities for the Seisflows solver interactions with
Specfem3D Cartesian.
"""
import os
import time
from glob import glob
from seisflows import logger
from seisflows.tools import unix
from seisflows.tools.specfem import setpar, getpar
from seisflows.solver.specfem import Specfem


class Specfem3D(Specfem):
    """
    Solver SPECFEM3D
    ----------------
    SPECFEM3D-specific alterations to the base SPECFEM module

    Parameters
    ----------
    :type source_prefix: str
    :param source_prefix: Prefix of source files in path SPECFEM_DATA. Must be
        in ['CMTSOLUTION', 'FORCESOLUTION']. Defaults to 'CMTSOLUTION'
    :type export_vtk: bool
    :param export_vtk: at the finalization step of each iteration, convert
        all eligible model and gradient directories in the `path_output`
        to .vtk files for visualization using ParaView (or similar programs). 
        Files are exported to `path_output`/VTK
    :type prune_scratch: bool
    :param prune_scratch: prune/remove database files as soon as they are used,
        to keep overall filesystem burden down
        - removes *.vt? files after they're generated by a forward simulation
        - removes proc*_absorb_field.bin and proc*_save_forward_array.bin
            files after adjoint simulations

    Paths
    -----
    ***
    """
    __doc__ = Specfem.__doc__ + __doc__

    def __init__(self, source_prefix="CMTSOLUTION", export_vtk=True, 
                 prune_scratch=True, **kwargs):
        """
        Instantiate a Specfem3D_Cartesian solver interface
        
        .. note:: Repeated variables

            For variables that are expressed as both public and private (one
            leading underscore), we have a public version so that the parameter
            will show up in the parameter file, and a private one so that the 
            other SPECFEM versions can use it for boolean logic without
            necessarily needing to include it in their parameter file since it
            is not accessed and therefore not necessary.
        """

        super().__init__(source_prefix=source_prefix, **kwargs)

        self.prune_scratch = prune_scratch

        # See note about repeated variables above
        self.export_vtk = export_vtk
        self._export_vtk = export_vtk
        
        # Define parameters based on material type
        if isinstance(self.materials, list):
            self._parameters += self.materials
        elif self.materials.upper() == "ACOUSTIC":
            self._parameters += ["vp"]
        elif self.materials.upper() == "ELASTIC":
            self._parameters += ["vp", "vs"]
        elif self.materials.upper() == "ANISOTROPIC":
            # General 21 parameter anisotropy: c11, c12... c66
            for i in range(1, 7):
                for j in range(1, 7):
                    if j >= i:
                        self._parameters.append(f"c{i}{j}")
        else:
            raise NotImplementedError(f"invalid material: {self.materials}")

        # Overwriting the base class parameters
        self._acceptable_source_prefixes = ["CMTSOLUTION", "FORCESOLUTION"]
        self._required_binaries = ["xspecfem3D", "xmeshfem3D",
                                   "xgenerate_databases", "xcombine_sem",
                                   "xsmooth_sem"]  #, "xcombine_vol_data_vtk"]

        # Overwriting constants that will be referenced during simulations 
        self._fwd_simulation_executables = [
            "bin/xmeshfem3D", "bin/xgenerate_databases", "bin/xspecfem3D"
            ]

        self._adj_simulation_executables = ["bin/xspecfem3D"]
        self._absorb_wildcard = "proc??????_absorb_field*"
        self._forward_array_wildcard = "proc??????_save_forward_arrays*"

        # Internally used parameters set by functions within class
        self._model_databases = None
        self.path._vtk_files = os.path.join(self.path.scratch, "vtk_files")

    def check(self):
        """SPECFEM3D_Cartesian specific check tasks"""
        super().check()

        if self.materials.upper() == "ANISOTROPIC":
            logger.warning("the 'ANISOTROPIC' material parameter is an "
                           "experimental feature that requires "
                           "a modified version of SPECFEM3D. Use at your own "
                           "risk, not guaranteed to work")

            anisotropic_kl = getpar(key="ANISOTROPIC_KL", 
                                    file=os.path.join(self.path.specfem_data, 
                                                      "Par_file"))[1]
            assert(anisotropic_kl == ".true."), (
                f"SPECFEM3D Par_file parameter 'ANISOTROPIC_KL' must be set "
                f"'.true.' for ANISOTROPIC parameters"
                )


    def setup(self):
        """
        Generate .vtk files for the initial and target (if applicable) models,
        which the User can use for external visualization
        """
        super().setup()

    def data_wildcard(self, comp="?"):
        """
        Returns a wildcard identifier for synthetic data

        TODO where does SU put its component?

        :rtype: str
        :return: wildcard identifier for channels
        """
        if self.syn_data_format.upper() == "SU":
            return f"*_d?_SU"
        elif self.syn_data_format.upper() == "ASCII":
            return f"*.?X{comp}.sem?"

    @property
    def model_databases(self):
        """
        The location of databases for model outputs, usually
        OUTPUT_FILES/DATABASES_MPI. This can be determined by 'LOCAL_PATH'
        in your Par_file
        """
        if self._model_databases is None:
            self._model_databases = getpar(
                key="LOCAL_PATH", file=os.path.join(self.path.specfem_data,
                                                    "Par_file"))[1]
        return self._model_databases

    @property
    def kernel_databases(self):
        """
        The location of databases for kernel outputs, usually the same as
        'model_databases'
        """
        return self.model_databases

    def forward_simulation(self, **kwargs):
        """
        Calls SPECFEM3D forward solver, exports solver outputs to traces dir

        See `solver.specfem.forward_simulation` for info on required parameters
        """
        unix.cd(self.cwd)

        if glob(os.path.join(self.model_databases, "proc*_Database")):
            # Drop xmeshfem3D if we have already run it once. Only once per run
            self._fwd_simulation_executables = \
                self._fwd_simulation_executables[1:]

        # SPECFEM3D has to deal with attenuation
        if self.attenuation:
            setpar(key="ATTENUATION", val=".true.", file="DATA/Par_file")
        else:
            setpar(key="ATTENUATION", val=".false`.", file="DATA/Par_file")

        super().forward_simulation(**kwargs)

    def adjoint_simulation(self, **kwargs):
        """
        Calls SPECFEM3D adjoint solver, creates the `SEM` folder with adjoint
        traces which is required by the adjoint solver

        See `solver.specfem.adjoint_simulation` for info on required parameters

        :type executables: list or None
        :param executables: list of SPECFEM executables to run, in order, to
            complete an adjoint simulation. This can be left None in most cases,
            which will select default values based on the specific solver
            being called (2D/3D/3D_GLOBE). It is made an optional parameter
            to keep the function more general for inheritance purposes.
        """
        # Make sure attenuation is OFF, if ON you'll get a floating point error
        unix.cd(self.cwd)
        setpar(key="ATTENUATION", val=".false.", file="DATA/Par_file")

        # Make sure we have a STATIONS_ADJOINT file. Simply copy STATIONS file
        # we expect that preprocessing has created ALL required adjoint sources
        dst = os.path.join(self.cwd, "DATA", "STATIONS_ADJOINT")
        if not os.path.exists(dst):
            src = os.path.join(self.cwd, "DATA", "STATIONS")
            unix.cp(src, dst)

        # SPECFEM class takes care of `simulation_type`` and `save_forward`` 
        # params as well as kernel renaming and export and scratch pruning
        super().adjoint_simulation(**kwargs)

    def combine_vol_data_vtk(self, input_path, output_path, hi_res=False,
                             parameters=None):
        """
        Wrapper for 'xcombine_vol_data_vtk'. Combines binary files together
        to generate a single .VTK file that can be visualized by external
        software like ParaView

        .. rubric::
            xcombine_data start end quantity input_dir output_dir hi/lo-res

        .. note::
            It is ASSUMED that this function is being called by
            system.run(single=True) so that we can use the main solver
            directory to perform the kernel summation task

        :type input_path: str
        :param input_path: path to database files to be summed.
        :type output_path: strs
        :param output_path: path to export the outputs of the binary
        :type hi_res: bool
        :param hi_res: Set the high resolution flag to 1 or True, which will
            generate .vtk files with data at EACH GLL point, rather than at each
            nodal vertex. These files are LARGE, and we discourage using
            `hi_res`==True unless you know you want these files.
        :type parameters: list
        :param parameters: optional list of parameters,
            defaults to `self._parameters`
        """
        unix.cd(self.cwd)

        if parameters is None:
            parameters = self._parameters

        if not os.path.exists(output_path):
            unix.mkdir(output_path)

        # Call on xcombine_sem to combine kernels into a single file
        for name in parameters:
            # e.g.:  bin/xcombine_vol_data_vtk 0 3 alpha_kernel in/ out/ 0
            exc = f"bin/xcombine_vol_data_vtk 0 {self.nproc-1} {name} " \
                  f"{input_path} {output_path} {int(hi_res)}"
            # e.g., smooth_vp.log
            stdout = f"{self._exc2log(exc)}_{name}.log"
            self._run_binary(executable=exc, stdout=stdout, with_mpi=False)

