#!/usr/bin/env python3
"""
Ambient Noise Adjoint Tomography Forward Solver based on the workflow proposed
by Wang et al. where synthetic Greens functinos (SGF) are generated by
simulating point forces.

Reference
- "Three‚Äêdimensional sensitivity kernels for multicomponent empirical Green's
  functions from ambient noise: Methodology and application to Adjoint
  tomography."
  Journal of Geophysical Research: Solid Earth 124.6 (2019): 5794-5810.

"""
import os
from glob import glob
from seisflows import logger
from seisflows.tools import unix
from seisflows.workflow.inversion import Inversion


class NoiseInversion(Inversion):
    """
    Noise Inversion Workflow
    ------------------------
    Run forward and adjoint solvers to produce Synthetic Greens Functions (SGF)
    based on unidirectional forces which are meant to represent virtual
    sources of uniform noise distributions. SGFs are compred to Empirical
    Greens Functions (EGF) for iterative model updates.

    Parameters
    ----------
    :type kernels: str
    :param kernels: comma-separated list of kernels to generate w.r.t available
        EGF data. Corresponding data must be available. Available options are:

        - 'ZZ': vertical component force recorded on vertical component.
          Represents Rayleigh wave energy
        - 'TT': transverse copmonent force recorded on transverse component.
          Represents Love wave energy
        - 'RR': radial component force recorded on radial component.
          Represents Rayleigh wave energy

        Example input would be `kernels`='ZZ,TT'. Case insensitive

    Paths
    -----

    ***
    """
    def __init__(self, kernels="ZZ", **kwargs):
        """
        Initialization of the Noise Inversion Workflow module
        """
        super().__init__(**kwargs)

        self.kernels = kernels.upper()
        self.kernel = None

    def check(self):
        """Additional checks for the Noise Inversion Workflow"""
        super().check()

        acceptable_kernels = {"ZZ", "TT", "RR"}
        assert(set(self.kernels.split(",")).issubset(acceptable_kernels)), \
            f"`kernels` must be a subset of {acceptable_kernels}"

        import pdb;pdb.set_trace()

        assert(self.data_case == "data"), \
            f"Noise Inversion workflow must have `data_case` == 'data'"

    @property
    def task_list(self):
        """
        USER-DEFINED TASK LIST. This property defines a list of class methods
        that take NO INPUT and have NO RETURN STATEMENTS. This defines your
        linear workflow, i.e., these tasks are to be run in order from start to
        finish to complete a workflow.

        This excludes 'check' (which is run during 'import_seisflows') and
        'setup' which should be run separately

        .. note::
            For workflows that require an iterative approach (e.g. inversion),
            this task list will be looped over, so ensure that any setup and
            teardown tasks (run once per workflow, not once per iteration) are
            not included.

        :rtype: list
        :return: list of methods to call in order during a workflow
        """
        task_list = []
        # Determine which kernels we will generate during the workflow
        if "ZZ" in self.kernels:
            task_list.append(self.generate_zz_kernels)
        # These components can be run together because they use the same sims
        if "TT" in self.kernels or "RR" in self.kernels:
            task_list.append(self.generate_tt_rr_kernels)

        task_list = task_list.extend([
            self.postprocess_event_kernels,
            self.evaluate_gradient_from_kernels,
            self.initialize_line_search,
            self.perform_line_search,
            self.finalize_iteration
        ])

        return task_list

    def prepare_data_for_solver(self, **kwargs):
        """
        Overwrites workflow.forward.prepare_data_for_solver() by changing
        the location of expected data, and removing any data previously stored
        within the `solver/traces/obs/` directory.

        Also completely ignores 'synthetic' data case because noise workflow
        only works with data.

        This will be run within the `evaluate_initial_misfit` function

        .. note ::
            Must be run by system.run() so that solvers are assigned individual
            task ids and working directories
        """
        logger.info(f"preparing observation data for source "
                    f"{self.solver.source_name}")

        logger.info(f"copying {self.kernel} data from `path_data`")
        src = os.path.join(
            self.path.data, self.solver.source_name, self.kernel, "*"
        )
        dst = os.path.join(self.solver.cwd, "traces", "obs", "")

        # Remove any existing data that might have been placed here by previous
        # parts of the workflow
        unix.rm(glob(os.path.join(dst, "*")))
        unix.cp(glob(src), dst)

    def generate_zz_kernels(self):
        """
        Generate Synthetic Greens Functions (SGF) for the ZZ component by
        running simulations for each master station using a Z component force.
        """
        # This will be used to reference for data retrieval
        self.kernel = "ZZ"

        # This is for FORCESOLUTION (3D/3D_GLOBE) only, ensure that
        # we are using a vertical source (pointing up)
        self.solver.modify_source_files(key="component dir vect source E",
                                        val="0.d0")
        self.solver.modify_source_files(key="component dir vect source N",
                                        val="0.d0")
        self.solver.modify_source_files(key="component dir vect source Z_UP",
                                        val="1.d0")

        # Run the forward solver to generate SGFs and adjoint sources
        super().evaluate_initial_misfit()
        # Run the adjoint solver to generate kernels for
        super().run_adjoint_simulations()

    def generate_tt_rr_kernels(self):
        """
        Generate Synthetic Greens Functions (SGF) for the TT and/or RR
        component(s) by running simulations for each master station using an
        N and E component force (separately), rotating the components to T and
        R, and then reinjecting .
        """


