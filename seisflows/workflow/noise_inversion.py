#!/usr/bin/env python3
"""
Ambient Noise Adjoint Tomography workflowe based on Wang et al. (see ref. below)
where Synthetic Greens functions (SGF) are generated by simulating point forces
in the Z, N and E directions, and SGFs are rotated to the R and T components
to get data-comparable ZZ, RR and TT SGFs.

.. note:: EGF Data Location

    EGF data must be placed in specific directory structures, and are searched
    for under the following locations for a given kernel:

        ZZ kernel: `path_data`/{source_name}/ZZ/*
        RR kernel: `path_data`/{source_name}/RR/*
        TT kernel: `path_data`/{source_name}/TT/*

.. note:: Kernel Naming

    The kernel naming convention used in this workflow follows from Ref. 1.
    Two letter names (e.g., AB) where first letter (A) represents input force
    direction, and second letter (B) represents the component of the recorded
    wavefield. E.g., ZZ represents an upward (+Z) force recorded on Z component.
    In ambient noise, the common EGFs are ZZ, TT and RR. Cross-component EGFs
    (e.g., ZT) are also possible.

.. note:: References

    1. "Threeâ€dimensional sensitivity kernels for multicomponent empirical
        Green's functions from ambient noise: Methodology and application to
        Adjoint tomography."
        Journal of Geophysical Research: Solid Earth 124.6 (2019): 5794-5810.

.. warning::

    This workflow class makes a lot of assumptions about file naming and 
    path structure defined in other modules that is verging on hard coding. May
    warrant a re-write in the future.  I've tried to mark all the file/dir.
    naming assumptions with a '!!!'
"""
import os
import numpy as np
from glob import glob
from seisflows import logger
from seisflows.tools import unix, msg
from seisflows.workflow.inversion import Inversion


class NoiseInversion(Inversion):
    """
    Noise Inversion Workflow
    ------------------------
    Run forward and adjoint solvers to produce Synthetic Greens Functions (SGF)
    based on unidirectional forces which are meant to represent virtual
    sources of uniform noise distributions. SGFs are compared to Empirical
    Greens Functions (EGF) for iterative model updates.

    .. note:: simulation requirements per source station

        - 'ZZ' kernel requires 1 forward (Z) and 1 adjoint (Z) simulation
        - 'TT or RR' kernel requires 2 forward (N + E) and 2 adjoint (N_? + E_?)
           simulations (where ? = R or T)
        - 'TT,RR' kernels can share their 2 forward simulations (N + E) but
          require 4 separate adjoint simulations (N_T + E_T + N_R + E_R)
        - 'ZZ,TT or ZZ,RR' requires 3 forward (Z + N + E) and 3 adjoint
        - 'ZZ,TT,RR' requires 3 forward (Z + N + E) and 5 adjoint
           (Z + N_T + E_T + N_R + E_R)

    Parameters
    ----------
    :type kernels: str
    :param kernels: comma-separated list of kernels to generate w.r.t available
        EGF data. Corresponding data must be available. Available options are:

        - 'ZZ': vertical component force recorded on vertical component.
          Represents Rayleigh wave energy
        - 'TT': transverse copmonent force recorded on transverse component.
          Represents Love wave energy
        - 'RR': radial component force recorded on radial component.
          Represents Rayleigh wave energy

        Example inputs would be 'ZZ' or 'ZZ,TT' or 'ZZ,TT,RR'. Case insensitive

    Paths
    -----

    ***
    """
    __doc__ = Inversion.__doc__ + __doc__

    def __init__(self, kernels="ZZ", **kwargs):
        """
        Initialization of the Noise Inversion Workflow module
        """
        super().__init__(**kwargs)

        self.kernels = kernels.upper()

        # Internal variables control behavior of spawned jobs. These should not
        # be set by the User, they are set by main processing functions here.
        self._force = None  # direction of input force for fwd/adj simulation
        self._cmpnt = None  # component of output synthetics/adjsrcs used

    def check(self):
        """
        Additional checks for the Noise Inversion Workflow to ensure the
        required modules and parameters are set
        """
        super().check()

        assert(self._modules.preprocess.__class__.__name__ == "Noise"), \
            f"Noise Inversion workflow require the `noise` preprocessing class"

        assert("3D" in self._modules.solver.__class__.__name__ ), (
            f"Noise Inversion workflow requires solver module 'specfem3d' or " 
            f"'specfem3d_globe'"
        )

        assert(self.data_case == "data"), \
            f"Noise Inversion workflow must have `data_case` == 'data'"

        assert(self._modules.solver.source_prefix == "FORCESOLUTION"), (
            f"Noise Inversion workflow requires solver `source_prefix` to be " 
            f"'FORCESOLUTION'"
        )

        acceptable_kernels = {"ZZ", "TT", "RR"}
        assert(set(self.kernels.split(",")).issubset(acceptable_kernels)), \
            f"`kernels` must be a subset of {acceptable_kernels}"

        # TODO: Check whether data exists for all sources/master stations

        # TODO: Check that solver parameter ROTATE_SEISMOGRAMS_RTZ == False (?)


    @property
    def task_list(self):
        """
        USER-DEFINED TASK LIST. This property defines a list of class methods
        that take NO INPUT and have NO RETURN STATEMENTS. This defines your
        linear workflow, i.e., these tasks are to be run in order from start to
        finish to complete a workflow.

        This excludes 'check' (which is run during 'import_seisflows') and
        'setup' which should be run separately

        .. note::

            For workflows that require an iterative approach (e.g. inversion),
            this task list will be looped over, so ensure that any setup and
            teardown tasks (run once per workflow, not once per iteration) are
            not included.

        :rtype: list
        :return: list of methods to call in order during a workflow
        """
        task_list = []

        # Determine which kernels we will generate during the workflow
        if "ZZ" in self.kernels:
            task_list.append(self.generate_zz_kernels)
        # These components can be run together because they use the same sims
        if "TT" in self.kernels or "RR" in self.kernels:
            task_list.append(self.generate_tt_rr_kernels)

        # Standard inversion tasks
        task_list.extend([
            self.postprocess_event_kernels,
            self.evaluate_gradient_from_kernels,
            self.initialize_line_search,
            self.perform_line_search,
            self.finalize_iteration
        ])

        return task_list

    def trace_path(self, tag, comp=None):
        """
        Convenience path function that returns the full path for storing
        intermediate waveform files for a given component. 
        These generally adhere to how the `solver` module names directories. 
        
        Required because this workflow will do a lot of pre-rotation waveform 
        storage, so we use this function as the once-and-for-all definition for 
        the paths

        .. note ::

            Must be run by system.run() so that solvers are assigned individual
            task ids and working directories

        :type tag: str or None
        :param tag: sub directory tag, e.g., 'syn' to store synthetic waveforms 
            and 'adj' to store adjoint sources.
        :type comp: str
        :param comp: optional component used to tag the sub directory
        :rtype: str
        :return: full path to solver scratch traces directory to save waveforms
        """
        if comp is not None:
            tag = f"{tag}_{comp}".lower()
        return os.path.join(self.solver.cwd, "traces", tag)

    def generate_zz_kernels(self):
        """
        Main processing function for Noise Inversion workflow. 

        Generates Synthetic Greens Functions (SGF) for the ZZ component by
        running forward simulations for each master station using a +Z component
        force, and then running an adjoint simulation to generate kernels.

        Some internal function overrides are required to adjust file and
        sub-directory naming structure to avoid conflict with the TT and RR 
        kernel generation.

        .. note::

            ZZ component kernel generation follows roughly the same workflow as 
            a standard earthquake based inversion.
        """
        # Internal tracking parameters used to name sub-directories, save
        # files and dictate how simulatuions are run
        self._force = "Z"
        self._cmpnt = "Z"

        # Run the forward solver to generate SGFs and adjoint sources
        self.evaluate_initial_misfit()

        # Run the adjoint solver to generate kernels for ZZ sensitive structure
        self.run_adjoint_simulations()

    def generate_tt_rr_kernels(self):
        """
        Main processing function for Noise Inversion workflow. 

        Generate Synthetic Greens Functions (SGF) for the TT and/or RR
        component(s) following processing steps laid out in Wang et al. (2019).

        .. note::

            This is significantly more complicated than the ZZ case because we
            need to rotate back and forth between the N and E simulations, and
            the R and T EGFs, which requires a lot of internal bookkeeping.

        TT/RR Workflow Steps:

          1. Run E component forward simulation, save traces & forward arrays
          2. Run N component forward simulations, save traces & forward arrays
          3. Rotate N and E component SGF to R and T components based on
             source-receiver azimuth values
          4. Calculate RR and TT adjoint sources (u_rr, u_tt) w.r.t EGF data

          5a. Rotate u_tt to N and E (u_ee, u_en, u_ne, u_nn)
          6a. Run ET adjoint simulation (injecting u_ee, u_en) for K_ET
          7a. Run NT adjoint simulation (injecting u_ne, u_nn) for K_NT
          8a. Sum T kernels, K_ET + K_NT = K_TT

          5a. Rotate u_rr to N and E (u_ee, u_en, u_ne, u_nn)
          6b. Run ER adjoint simulation (injecting u_ee, u_en) for K_ER
          7b. Run NR adjoint simulation (injecting u_ne, u_nn) for K_NR
          8b. Sum R kernels, K_ER + K_NR = K_RR

          9. Sum kernels K = K_RR + K_TT
        """
        logger.info(msg.mnr("EVALUATING RR/TT MISFIT FOR INITIAL MODEL"))

        # Run the forward solver to generate E? and N? SGFs and adjoint sources
        for force in ["E", "N"]:
            self._force = force
            logger.info(f"running misfit evaluation for comp: '{self._force}'")
            self.evaluate_initial_misfit()

        # Run adjoint solver for each kernel RR and TT (if requested) by
        # running two adjoint simulations (E and N) per kernel. 
        for cmpnt in ["T", "R"]:  
            # Skip over if User did not request 
            if cmpnt not in self.kernels:  # e.g., if 'R' in 'RR,TT'
                continue

            # Set internal kernel variable which will let all spawned jobs
            # know which set of adjoint sources are required for their sim
            logger.info(f"running generating kernel for component: {cmpnt}")
            self._cmpnt = cmpnt  # T or R

            # We require two adjoint simulations per kernel to recover gradient
            for force in ["E", "N"]:
                self._force = force
                logger.info(f"running adjoint simulation for "
                            f"'{self._force}{self._cmpnt}'")
                self.run_adjoint_simulations()

            # Unset internal variables to avoid any confusion in future runs
            self._cmpnt = None
            self._force = None

    def prepare_data_for_solver(self, **kwargs):
        """
        Function Override of `workflow.forward.prepare_data_for_solver()` 
        This will be run from within the `evaluate_initial_misfit` function.

        .. note ::

            Must be run by system.run() so that solvers are assigned individual
            task ids and working directories

        .. note::

            Changes the location of expected observed data, and removes any data
            previously stored within the `solver/traces/obs/` directory to avoid
            data conflict during workflow

            Data are searched for under the following locations:

                ZZ kernel: `path_data`/{source_name}/ZZ/*
                RR kernel: `path_data`/{source_name}/RR/*
                TT kernel: `path_data`/{source_name}/TT/*
        """
        # Define where the obs data is stored
        dst = self.trace_path("obs")

        # Since we need to run multiple preprocessing runs, we remove any
        # existing data that might have been placed here previously to avoid
        # data conflicts
        unix.rm(glob(os.path.join(dst, "*")))

        # Used for wildcard path naming ('ZZ,RR,TT' -> 'RT')
        wildcard = "".join([_[0] for _ in self.kernels.split(",") if _ != "ZZ"])

        # Generating a wildcard string that will be used to copy in data
        dir_ = {"Z": "ZZ",
                "N": f"[{wildcard}][{wildcard}]",  # [RT][RT] -> both RR and TT
                "E": f"[{wildcard}][{wildcard}]"
                }[self._force]

        # Access the specific 'obs' data path and feed that to the original fx.
        # !!! Assuming the data directory structure
        src = os.path.join(self.path.data, self.solver.source_name, dir_, "*")

        # Use Forward workflow machinery to copy in required EGF data
        super().prepare_data_for_solver(_src=src)

    def evaluate_objective_function(self, save_residuals=False, components=None,
                                    **kwargs):
        """
        Function Override of `workflow.inversion.evaluate_objective_function` to
        get expected adjoint sources for each kernel.

        ZZ kernel creation requires little modification and generally follows
        the original workflow function.

        RR and TT kernels require modification:
        - output synthetics are rotated from N/E to R/T, to match EGF data for
          misfit quantification
        - R and T adjoint sources are rotated back to N and E for
          adjoint simulations

        .. note::

            Must be run by system.run() so that solvers are assigned individual
            task ids/ working directories.
        """
        # Z component force behaves like a normal workflow, except that we only
        # create adjoint sources for the Z component, E and N will be zeros
        if self._force == "Z":
            super().evaluate_objective_function(save_residuals=save_residuals,
                                                components=["Z"])
        # Run E and N misfit quantification
        else:
            # We require both N and E forward simulations to be run prior to
            # preprocessing step
            n_traces = glob(os.path.join(self.trace_path("syn", "n"), "*"))
            e_traces = glob(os.path.join(self.trace_path("syn", "e"), "*"))
            if not n_traces or not e_traces:
                logger.info("not all required synthetics present for RR/TT "
                            "kernels, waiting for additional forward simulation"
                            )

                # Create a dummy residuals file so that the original function
                # doesn't complain when it tries to read it. Sort of hacky.
                # !!! Assuming filename based on function
                # !!! `inversion.evaluate_misfit_function`
                np.savetxt(
                        os.path.join(self.path.eval_grad, "residuals.txt"), [0]
                        )
                return

            # This will generate RR and TT synthetics in `traces/syn` with
            # synthetics generated using `traces/syn_e` and `traces/syn_n`
            logger.info("rotating N and E synthetics to RR and TT components")
            self.preprocess.rotate_ne_traces_to_rt(
                source_name=self.solver.source_name,
                syn_path=self.trace_path(tag="syn", comp="{}"),
                data_wildcard=self.solver.data_wildcard(comp="{}"),
                kernels=self.kernels
            )
            # Run preprocessing with rotated synthetics for N and E only,
            # generate adjoint sources for R and T components
            super().evaluate_objective_function(save_residuals=save_residuals,
                                                components=["T", "R"]
                                                )
            # Re-rotate T and R adjoint sources to N and E components for 
            # adjoint simulations. Only rotate what is required for adj sim.
            for choice in ["T", "R"]:
                if choice in self.kernels:
                    self.preprocess.rotate_rt_adjsrcs_to_ne(
                        source_name=self.solver.source_name,
                        adj_path=self.trace_path(tag="adj", comp=None),
                        choice=choice,
                        )

    def run_forward_simulations(self, path_model, **kwargs):
        """
        Function Override of `workflow.forward.run_forward_simulation` 

        Performs curated FORCESOLUTION file manipulation and output file 
        redirects to get synthetic waveform data in the correct location for
        future preprocessing steps. Able to handle Z, N and E forces required 
        for ZZ, TT and RR kernel generation.

        .. note::

            Must be run by system.run() so that solvers are assigned individual
            task ids/ working directories.

        :type path_model: str
        :param path_model: path to SPECFEM model files used to run the forwarsd
            simulations. Files will be copied to each individual solver
            directory.
        :raises AssertionError: if internal variable `_force` is not set by
            the calling function
        """
        # Internal variable check
        assert(self._force is not None), (
            f"`run_forward_simulation` requires that the internal attribute " 
            f"`_force` is set prior to running forward simulations"
        )

        # Edit the force vector based on the internal value for chosen kernel
        kernel_vals, save_traces = None, None
        if self._force == "Z":
            kernel_vals = ["0.d0", "0.d0", "1.d0"]  # format: [E, N, Z]
            # ZZ SGFs are just saved straight to the 'syn' directory
            save_traces = self.trace_path(tag="syn")
        else:
            if self._force == "N":
                kernel_vals = ["0.d0", "1.d0", "0.d0"]  # format: [E, N, Z]
            elif self._force == "E":
                kernel_vals = ["1.d0", "0.d0", "0.d0"]  # format: [E, N, Z]
            # e.g., solver/{source_name}/traces/syn_e
            save_traces = self.trace_path(tag="syn", comp=self._force)

        # Set FORCESOLUTION (3D/3D_GLOBE) to ensure correct force for kernel
        self.solver.set_parameters(keys=["component dir vect source E",
                                         "component dir vect source N",
                                         "component dir vect source Z_UP"],
                                   vals=kernel_vals, file="DATA/FORCESOLUTION",
                                   delim=":")

        super().run_forward_simulations(path_model, save_traces=save_traces,
                                        **kwargs)

        # TODO >redirect output `export_traces` seismograms to honor kernel name

    def _run_adjoint_simulation_single(self, save_kernels=None, 
                                       export_kernels=None, **kwargs):
        """
        Function Override of `workflow.migration._run_adjoint_simulation_single`

        1) Creates necessary empty adjoint sources, e.g., ZZ kernel only 
           requires 'Z' component adjoint sources, and 'N' and 'E' MUST be 0
        2) For N and E (TT and RR kernels) adjoint simulations, symlinks collect
           adjoint sources to be discoverable by SPECFEM. Note that for 
           horizontal components, four sets of adjoint sources are available.

        .. note::

            Must be run by system.run() so that solvers are assigned
            individual task ids/working directories.
        """
        # Internal variable check
        assert(self._force is not None), (
            f"`run_adjoint_simulations` requires that the internal attribute " 
            f"`_force` is set prior to running forward simulations"
        )
        assert(self._cmpnt is not None), (
            f"`run_adjoint_simulations` requires that the internal attribute " 
            f"`_cmpnt` is set prior to running forward simulations"
        )
        # Kernel subdirectory should be one of: ZZ, NT, ET, NR, ER
        subdir = f"{self._force}{self._cmpnt}"

        # Redirect paths to where we save and export kernels to avoid overwrites
        if save_kernels is None:
            save_kernels = os.path.join(self.path.eval_grad, "kernels",
                                        self.solver.source_name, subdir)
        if export_kernels is None and self.export_kernels:
            export_kernels = os.path.join(self.path.output, "kernels",
                                          self.solver.source_name, subdir)
        else:
            export_kernels = False

        # Run adjoint simulations for each kernel
        if self._force == "Z":
            self._generate_empty_adjsrcs(components=["E", "N"])
            
            super()._run_adjoint_simulation_single(save_kernels, export_kernels)
        elif self._force in ["E", "N"]:
            # Remove any existing adjoint sources from directory 
            unix.rm(self.trace_path(tag="adj"))
            unix.mkdir(self.trace_path(tag="adj"))

            # Generate empty Z components because we only have E and N component
            self._generate_empty_adjsrcs(components=["Z"])

            # Symlink the correct set of adjoint sources to the 'adj' directory
            # `adj_dir` is something like 'adj_nt'
            adj_dir = self.trace_path(
                tag="adj", comp=f"{self._force.lower()}{self._cmpnt.lower()}"
            )
            for src in glob(os.path.join(adj_dir, "*")):
                unix.ln(src, self.trace_path("adj"))

            super()._run_adjoint_simulation_single(save_kernels, export_kernels)

    def _generate_empty_adjsrcs(self, components):
        """
        Internal NoiseInversion function used to generate empty (zero amplitude) 
        adjoint sources for every station and given `component`. Uses the Solver 
        and Preprocess modules to get after file naming and trace 
        characteristics.

        This function is required because the original Inversion method for 
        generating empty adjoint sources is insuffficient for the file structure
        that gets craeted here

        .. warning::

            !!! This entire function makes assumptions about file naming
            structure for SPECFEM generated synthetics that may be too rigid/
            hardcoded.

        .. note::

            Must be run by system.run() so that solvers are assigned
            individual task ids/working directories.

        :type components: list of str
        :param components: components to generate empty adjoint sources for.
            e.g., ['E', 'N'] will generate E and N component adjoint sources.
            Note that any files matching the output adjoint source file name
            will be removed so ensure that there is no actual adjoint source
            data in this file.
        """
        # Grab a dummy synthetic trace to use for time series structure
        st = self.preprocess.read(fid=self.solver.data_filenames("syn")[0],
                                  data_format=self.solver.syn_data_format)
        st[0].data *= 0  # zero out the amplitude for empty adjoint source

        # Get list of synthetic traces which require a corresponding adj source
        # and rename them so that they follow the expected SPECFEM format
        adj_fids = [
                self.preprocess.rename_as_adjoint_source(os.path.basename(f))
                for f in self.solver.data_filenames("syn")
                ]

        for fid in adj_fids:
            # !!! Making assumptions about the filenaming structure here
            component = fid.split(".")[2][-1]  # NN.SSS.CCc.adj  <- after 'c'
            # Only write components requested by the User or calling function
            if component not in components:
                continue
            adjpath = os.path.join(self.trace_path("adj"), fid)
            self.preprocess.write(st=st, fid=adjpath)

    def postprocess_event_kernels(self):
        """
        Function Override of `workflow.migration.postprocess_event_kernels`

        Combines multiple individual kernels, K, for each source.
        That is `K_event = K_ZZ + K_TT + K_RR`, where (K_TT = K_ET + K_NT and 
        K_RR = K_ER + K_NR). Uses the original function machinery to do the
        final kernel summation (K_misfit = sum(K_event)) and postprocessing
        (smoothing, masking, etc.)

        .. warning::

            Assumes the subdirectory structure of kernels for path `eval_grad`
        """
        # If only ZZ kernels, then we don't need to do any prior kernel summing.
        # Simply reorganize directory structures so that the original function
        # can find the required files
        if self.kernels == "ZZ":
            # $ mv kernels/src/ZZ/* -> kernels/src
            for srcname in self.solver.source_names:
                dst = os.path.join(self.path.eval_grad, "kernels", srcname)
                src = glob(os.path.join(dst, "ZZ", "*"))

                unix.mv(src=src, dst=dst)

            super().postprocess_event_kernels()

            # Return to avoid accessing code below which is only required if any
            # horizontal components are involved
            return

        # RR and TT kernels require running SPECFEM executable `xcombine_sem`
        # so we need to define a function which can be fed to 'system.run()'
        def generate_event_kernels(**kwargs):
            """
            Combine horizontal (TT=ET+NT; RR=ER+NR) kernels and then sum
            all individual kernel contributions (ZZ+RR+TT) to generate the final
            event kernel for each source.

            .. note::

                Must be run by system.run(single=True) so that the operation
                has access to the compute node for the kernel combination
            """
            # Parameters are constant and static for this whole process
            parameters = [f"{par}_kernel" for par in self.solver._parameters] 

            # We need to combine the N? and E? kernels for each source by itself
            for src in self.solver.source_names:
                # Subdirectory containing kernels for a given source
                # !!! Assuming the dir. structure defined by postprocess module
                src_path = os.path.join(self.path.eval_grad, "kernels", src)

                # This will bring in all available kernels from: ER, NR, ET, NT
                for kernel in ["RR", "TT"]:
                    if kernel not in self.kernels:
                        continue
                    input_paths = [os.path.join(src_path, f"E{kernel[0]}"),
                                   os.path.join(src_path, f"N{kernel[0]}")]

                # Sum in ZZ kernels to the final event kernel if available
                if "ZZ" in self.kernels:
                    input_paths.append(os.path.join(src_path, "ZZ"))

                # We drop the event kernel directly into the source 
                # subdirectory to match the expected input of the original fx.
                output_path = os.path.join(self.path.eval_grad, "kernels", src)

                # Use the solver function to combine kernels
                self.solver.combine(input_paths, output_path, parameters)
        
        # Run above function on system to get access to compute node
        self.system.run([generate_event_kernels], single=True)

        # Now the original function takes over and combines event kernels into
        # a misfit kernel, and applies smoothing, masking, etc.
        super().postprocess_event_kernels()

    def _evaluate_line_search_misfit(self):
        """
        Function Override of `workflow.inversion._evaluate_line_search_misfit`
        Called inside `workflow.inversion.perform_line_search`
        
        Line search requires running forward simulations multiple times to 
        generate the correct synthetics, as well as some synthetic rotation
        if TT or RR included in kernels

        .. warning::

            Each call of this function will save residuals but these will be 
            ignored and the final residual file will only be created once all 
            forward simulations are run
        """
        if "ZZ" in self.kernels:
            self._force = "Z"
            # Use this function to set the correct 'obs' data
            self.prepare_data_for_solver()
            super()._evaluate_line_search_misfit()

        if ("RR" in self.kernels) or ("TT" in self.kernels):
            self._force = "N"
            self.prepare_data_for_solver()
            super()._evaluate_line_search_misfit()

            self._force = "E"
            self.prepare_data_for_solver()
            super()._evaluate_line_search_misfit()


