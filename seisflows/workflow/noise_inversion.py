#!/usr/bin/env python3
"""
Ambient Noise Adjoint Tomography Forward Solver based on the workflow proposed
by Wang et al. where synthetic Greens functinos (SGF) are generated by
simulating point forces.

Reference
- "Threeâ€dimensional sensitivity kernels for multicomponent empirical Green's
  functions from ambient noise: Methodology and application to Adjoint
  tomography."
  Journal of Geophysical Research: Solid Earth 124.6 (2019): 5794-5810.

"""
import os
from glob import glob
from seisflows import logger
from seisflows.tools import unix, msg
from seisflows.workflow.inversion import Inversion


class NoiseInversion(Inversion):
    """
    Noise Inversion Workflow
    ------------------------
    Run forward and adjoint solvers to produce Synthetic Greens Functions (SGF)
    based on unidirectional forces which are meant to represent virtual
    sources of uniform noise distributions. SGFs are compred to Empirical
    Greens Functions (EGF) for iterative model updates.

    Parameters
    ----------
    :type kernels: str
    :param kernels: comma-separated list of kernels to generate w.r.t available
        EGF data. Corresponding data must be available. Available options are:

        - 'ZZ': vertical component force recorded on vertical component.
          Represents Rayleigh wave energy
        - 'TT': transverse copmonent force recorded on transverse component.
          Represents Love wave energy
        - 'RR': radial component force recorded on radial component.
          Represents Rayleigh wave energy

        Example input would be `kernels`='ZZ,TT'. Case insensitive

    Paths
    -----

    ***
    """
    __doc__ = Inversion.__doc__ + __doc__  

    def __init__(self, kernels="ZZ", **kwargs):
        """
        Initialization of the Noise Inversion Workflow module
        """
        super().__init__(**kwargs)

        self.kernels = kernels.upper()
        self._kernel = None

    def check(self):
        """Additional checks for the Noise Inversion Workflow"""
        super().check()

        acceptable_kernels = {"ZZ", "TT", "RR"}
        assert(set(self.kernels.split(",")).issubset(acceptable_kernels)), \
            f"`kernels` must be a subset of {acceptable_kernels}"

        assert(self.data_case == "data"), \
            f"Noise Inversion workflow must have `data_case` == 'data'"

    @property
    def task_list(self):
        """
        USER-DEFINED TASK LIST. This property defines a list of class methods
        that take NO INPUT and have NO RETURN STATEMENTS. This defines your
        linear workflow, i.e., these tasks are to be run in order from start to
        finish to complete a workflow.

        This excludes 'check' (which is run during 'import_seisflows') and
        'setup' which should be run separately

        .. note::
            For workflows that require an iterative approach (e.g. inversion),
            this task list will be looped over, so ensure that any setup and
            teardown tasks (run once per workflow, not once per iteration) are
            not included.

        :rtype: list
        :return: list of methods to call in order during a workflow
        """
        task_list = []

        # Determine which kernels we will generate during the workflow
        if "ZZ" in self.kernels:
            task_list.append(self.generate_zz_kernels)
        # These components can be run together because they use the same sims
        if "TT" in self.kernels or "RR" in self.kernels:
            task_list.append(self.generate_tt_rr_kernels)

        # Standard inversion tasks
        task_list.extend([
            self.postprocess_event_kernels,
            self.evaluate_gradient_from_kernels,
            self.initialize_line_search,
            self.perform_line_search,
            self.finalize_iteration
        ])

        return task_list

    def prepare_data_for_solver(self, **kwargs):
        """
        Overrides workflow.forward.prepare_data_for_solver() by changing
        the location of expected data, and removing any data previously stored
        within the `solver/traces/obs/` directory.

        This will be run within the `evaluate_initial_misfit` function

        .. note ::

            Must be run by system.run() so that solvers are assigned individual
            task ids and working directories
        """
        # Use the forward workflow machinery to get data from external directory
        # but change the expected location of data which needs to be categorized
        # by kernel type
        src = os.path.join(
            self.path.data, self.solver.source_name, self._kernel, "*"
        )
        super().prepare_data_for_solver(_src=src)

        # We are assuming `dst` structure here is fixed w.r.t forward workflow
        dst = os.path.join(self.solver.cwd, "traces", "obs", "")

        # Remove any existing data that might have been placed here by previous
        # parts of the workflow
        unix.rm(glob(os.path.join(dst, "*")))
        unix.cp(glob(src), dst)

    def run_forward_simulations(self, path_model, **kwargs):
        """
        Modifies the `forward.run_forward_simulation` to do some additional file
        manipulations and output file redirects to prepare for noise inversion.

        Internal parameter `_kernel` needs to be set by the calling functions
        prior to running forward simulations.

        .. note::
            Must be run by system.run() so that solvers are assigned individual
            task ids/ working directories.
        """
        # Edit the force vector based on the internaly value for chosen kernel
        if self._kernel == "ZZ":
            kernel_vals = ["0.d0", "0.d0", "1.d0"]  # E,N,Z
        elif self._kernel == "NN":
            kernel_vals = ["0.d0", "1.d0", "0.d0"]  # E,N,Z
        elif self._kernel == "EE":
            kernel_vals = ["1.d0", "0.d0", "0.d0"]  # E,N,Z
        else:
            raise NotImplementedError  # user should not get here

        # Set FORCESOLUTION (3D/3D_GLOBE) to ensure correct force for kernel
        self.solver.set_parameters(keys=["component dir vect source E",
                                         "component dir vect source N",
                                         "component dir vect source Z_UP"],
                                   vals=kernel_vals, file="DATA/FORCESOLUTION",
                                   delim=":")

        super().run_forward_simulations(path_model, **kwargs)

        # TODO >redirect output `export_traces` seismograms to honor kernel name

    def generate_zz_kernels(self):
        """
        Generate Synthetic Greens Functions (SGF) for the ZZ component by
        running simulations for each master station using a Z component force.
        """
        # This will be referenced in `run_forward_simulations`
        self._kernel = "ZZ"

        # Run the forward solver to generate SGFs and adjoint sources
        super().evaluate_initial_misfit()

        # Run the adjoint solver to generate kernels for ZZ sensitive structure
        super().run_adjoint_simulations()

    def generate_tt_rr_kernels(self):
        """
        Generate Synthetic Greens Functions (SGF) for the TT and/or RR
        component(s) by running simulations for each master station using an
        N and E component force (separately), rotating the components to T and
        R, and then reinjecting .

        This is slightly more complicated than the ZZ case because we need to
        retain both the E and N kernels for rotation and adjoint simulations.
        """
        # Run the forward solver to generate ET SGFs and adjoint sources
        self._kernel = "EE"
        super().evaluate_initial_misfit()


        # Run the forward solver to generate SGFs and adjoint sources
        self._kernel = "NT"
        super().evaluate_initial_misfit()

        # Get preprocess module to rotate synthetics into proper
